% Compute the segmentation by grabcut from outlines made with Amazon murk.
% path : the folder where the batch.csv is stored.
% All the results are generated from this file
% The images used for training are to be stored in the Train directory.
% constraint : 'skeleton' ou 'erosion', méthode d'amélioration du
% foreground initial


function otis_mturk(path, constraint, fg_constraint)

close all;

prepareData(path, nb_hit);

computeSegmentation(path, constraint, fg_constraint);

displayInit(path, constraint);


end

function prepareData(path)

% Copy the images needed in the right folder
fetch_images(path);

% Create the json files from the csv generated by Amazon
delete([path, '/*.json']);
nb_images = generate_json(path);
image_extensions = {'jpg','png'};

% Récupérer les images et leur chemins
img_names = []; img_paths = [];
for k = 1:length(image_extensions)
    [fn, fp] = Utils.getFiles(path,image_extensions{k});
    img_names = [img_names fn];
    img_paths = [img_paths fp];
end

% Créer le .mat qui contient les images
if ~exist([path '/images.mat'])
        for i=1:length(img_names)
            eval(['I' int2str(i) '=imread(''' img_paths{i} ''');']);
            if (i~=1)
                save([path '/images.mat'],['I' int2str(i)],'-append');
            else
                save([path '/images.mat'],['I' int2str(i)]);
            end
        end
    save([path '/images.mat'],'nb_images');
end

% Créer le .mat qui contient les superpixels de chaque image
if ~exist([path '/superpixels.mat'])
    SP.MeanShift.all(img_paths,path); %Superpixelisation de toutes les images
    splitter = split(path, '/');
    dos = splitter{end};
    for i=1:length(img_names)
        load([path '/' dos, '/' img_names{i} '.mat']);
        eval(['SP_' img_names{i} '=varargout{1};']);
        if (i~=1)
            save([path '/superpixels.mat'],['SP_' img_names{i}],'-append');
        else
            save([path '/superpixels.mat'],['SP_' img_names{i}]);
        end
    end
end

if ~exist([path '/outlines.mat'])
    load([path '/images.mat'])
    for i=1:nb_images
        aux = Utils.loadjson([path '/' int2str(i), '.json']);
        
        % Trouver la classe de l'image et son nom
        URL = aux.images{1,1}.image;
        URL=split(URL, '/');
        
        nom_image = URL(end);
        nom_image = nom_image{1};
        classe = URL(end-1);
        classe=classe{1};
        classe = classe(7:end);
        
        eval(['classe' int2str(i) '=classe;']);
        eval(['nom_image' int2str(i) '=nom_image;']);
        
        % Non testé avec la dernière version : Elargir les outlines
        %             os = aux.images{1,1}.annotations{1,1}.annotations;
        %             if length(os)~=0
        %                 for j=1:length(os)
        %                     coord = os{j};
        %                     cx = coord(:,1);
        %                     cy = coord(:,2);
        %                     [L, C] = size(img(:,:,1));
        %                     mask = poly2mask(cx, cy, L, C);
        %                     se = strel('diamond', 5);
        %                     mask = imdilate(mask, se);
        %                     boundaries = boundarymask(mask, 4);
        %                     indices = find(boundaries == true);
        %                     [coordy, coordx] = ind2sub([L,C], indices);
        %                     aux.images{1,1}.annotations{1,1}.annotations{j} = [coordx, coordy];
        %                 end
        %             end
        
        eval(['outlines' int2str(i) '=aux;']);
        if ~(i==1)
            save([path '/outlines.mat'],['outlines' int2str(i)],'-append');
            save([path '/classe.mat'],['classe' int2str(i)],'-append');
            save([path '/nom_images.mat'],['nom_image' int2str(i)],'-append');
        else
            save([path '/outlines.mat'],['outlines' int2str(i)]);
            save([path '/classe.mat'],['classe' int2str(i)]);
            save([path '/nom_images.mat'],['nom_image' int2str(i)]);
        end
        
    end
    
end
end

function computeSegmentation(path, constraint, fg_constraint, bg_constraint)

if  ~exist([path '/results.mat'])
    
    load([path '/outlines.mat'])
    load([path '/superpixels.mat'])
    load([path '/nom_images.mat'])
    load([path '/classe.mat'])
    
    nb_obj = [];
    for i = 1:nb_images
        
        eval(['nom_image = nom_image' int2str(i) ';']);
        img = imread([path '/' nom_image]);
        nom_image = split(nom_image, '.');
        nom_image = nom_image{1};
        eval(['sp = SP_' nom_image ';']);
        
        disp(['Segmenting image #' int2str(i)]);
        eval(['outline = outlines' int2str(i) ';']);
        os = outline.images{1,1}.annotations{1,1}.annotations;
        nb_obj(i) = 0;

        if length(os)~=0
            for h = 1:length(os)
                o = os{h};
                % not enough points to compute the grabcut
                if size(o,1) >= 3
                    
                    try
                        r = floor(Outline.maxRadius(o)/2);
                    catch ME
                        r = [];
                    end
                    % Case the outlining is too bad : no radius, do not
                    % compute the grabcut
                    if ~isempty(r)
                        [seg, ~,~, skel, fg_init] = Outline.grabcut(img, o, r, sp, constraint, bg_constraint);
                        nb_obj(i) = nb_obj(i) + 1;
                        eval(['seg' int2str(i)  '_' int2str(nb_obj(i)) '= seg;']);
                        eval(['skel' int2str(i)  '_' int2str(nb_obj(i)) '= skel;']);
                        eval(['fg_init' int2str(i)  '_' int2str(nb_obj(i)) '= fg_init;']);
                        
                        if (i~=1)
                            save([path '/results.mat'],['seg' int2str(i)  '_' int2str(nb_obj(i))], ...
                                ['skel' int2str(i)  '_' int2str(nb_obj(i))],...
                                ['fg_init' int2str(i)  '_' int2str(nb_obj(i))],...
                                '-append');
                        else
                            save([path '/results.mat'],['seg' int2str(i)  '_' int2str(nb_obj(i))], ...
                                ['skel' int2str(i)  '_' int2str(nb_obj(i))],...
                                ['fg_init' int2str(i)  '_' int2str(nb_obj(i))]);
                        end
                        
                        clear seg
                        clear fg_init
                        clear skel
                    end
                end
            end
        end
        clear outline
    end
    clear img
    clear sp
    save([path '/results.mat'],'nb_obj', '-append');
end
end

function displayInit(path, constraint)

load([path, '/outlines.mat']);
load([path, '/images.mat']);
load([path, '/classe.mat']);
load([path, '/nom_images.mat']);
load([path, '/results.mat']);
load([path '/superpixels.mat']);

for i =1:nb_images
    
    fig = figure('Position', [10,10,800,800]);
    
    eval(['outline = outlines' int2str(i) ';']);
    eval(['nom_image = nom_image' int2str(i) ';']);
    eval(['classe = classe' int2str(i) ';']);
    img = imread([path '/' nom_image]);
    nom_image = split(nom_image, '.');
    nom_image = nom_image{1};
    
    eval(['sp = SP_' nom_image ';']);
    
    subplot(2,2,1);
    imshow(img, 'InitialMag', 'fit')
    hold on
    
    subplot(2,2,2);
    imshow(img, 'InitialMag', 'fit')
    hold on
    
    subplot(2,2,3:4);
    imshow(img, 'InitialMag', 'fit')
    hold on
    
    subplot(2,2,1);
    % plot the original outlines
    for k=1:size(outline.images{1,1}.annotations{1,1}.annotations, 1 )
        coord = outline.images{1}.annotations{1}.annotations{k};
        hold on
        plot(coord(:,1), coord(:,2),'LineWidth',2);
    end
    title(["Outline & ", constraint]);
    
    for j = 1:nb_obj(i)
        eval(['skel = skel' int2str(i) '_' int2str(j) ';']);
        eval(['fg_init = fg_init' int2str(i) '_' int2str(j) ';']);
        eval(['seg = seg' int2str(i) '_' int2str(j) ';']);
        
        % Plot the skeleton or the erosion
        subplot(2,2,1);
        if strcmp(constraint, 'skeleton') && any(skel(:))
            skel = skel';
            plot(skel(:,1), skel(:,2), 'r.');
            directory = 'skeleton';
            
        else
            red = cat(3, ones(size(skel)), zeros(size(skel)), zeros(size(skel)));
            h1 = imshow(red);
            alpha = 128*uint8(skel);
            set(h1,'AlphaData',alpha);
            directory = 'erosion';
            
        end
        
        % plot the computed superpixels
        subplot(2,2,2);
        blue = cat(3, zeros(size(fg_init)), zeros(size(fg_init)), ones(size(fg_init)));
        h1 = imshow(blue);
        alpha = 128*uint8(fg_init);
        set(h1,'AlphaData',alpha);
        title("Superpixels");
        
        %Finally, plot the results
        subplot(2,2,3:4);
        alpha = 128*uint8(seg);
        green = cat(3, zeros(size(seg)), ones(size(seg)), zeros(size(seg)));
        hold on
        h1 = imshow(green);
        hold off
        set(h1,'AlphaData',alpha);
        title("Segmentation");
        
    end
    saveas(fig, ['C2_figures_sans_elargissement_soft_hard/', directory, '/' classe '/image_', num2str(i) '.png']);
    close
    
end

end

